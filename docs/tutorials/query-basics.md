# Query with filters and unique keys

This tutorial shows examples using the data that was loaded in the [Your first schema in five minutes](./first-schema.md) tutorial. You can follow along with your own data, but the names of objects generated by the schema introspection will be different so please adjust queries accordingly.

Goal: make a couple of real queries and see how the schema is shaped.

## 1) Find the types

GraphQL uses well know objects to make know the GraphQL schema, we will query those so we can see what types have been discovered:

```graphql
{
  __schema {
    types {
      name
      kind
    }
  }
}
```

Pick the object type that matches the table you are interested in querying.

## 2) Query rows

Using the schema created from the [sample-data.sql](./sample-data.sql) we will query the users table:

```graphql
query BasicUserQuery {
  users {
    nodes {
      fullName
      email
      status
    }
  }
}
```

Note: You can give a query an optional name, in this case we called our query `BasicUserQuery`.

## 3) Use filters

TiDB GraphQL enables you to create filters on certain columns. Filters mirror SQL WHERE semantics.

For example, we can filter the users to those who do not have certain statuses:

```graphql
query {
  users(where: { status: { notIn: ["pending", "inactive"] } }) {
    nodes {
      fullName
      email
      status
    }
  }
}
```

You can combine filters with `and` / `or`, and compare with `lt`, `lte`, `gt`, `gte`, `ne`, etc.

## 4) Sort results with orderBy

Sorting uses `orderBy` with a list of fields and directions:

```graphql
query {
  users(orderBy:{createdAt:DESC}) {
    nodes {
      fullName
      email
      status
    }
  }
}
```

## 5) Cursor pagination of results

TiDB GraphQL uses cursor pagination on collection fields.

For example, returning the first 2 results:

```graphql
query {
  users(orderBy:{createdAt:DESC}, first:2) {
    edges {
      cursor
      node {
        fullName
        email
        status
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
```

Next, returning the next 2 results using the previous `endCursor`:

```graphql
query {
  users(orderBy:{createdAt:DESC}, first:2, after:"<cursor-from-previous-page>") {
    edges {
      node {
        fullName
        email
        status
      }
    }
  }
}
```

## 6) Fetch by primary key

Every table with a primary key gets a singular lookup field using the table's singular name:

```graphql
query test {
  user(id:"WyJVc2VyIiwgMV0="){
    fullName
    email
    status
  }
}
```

This compiles to a direct indexed lookup and returns a single object (or null if not found).

The `id` is a global Node ID (base64-encoded). If you need raw primary key lookups, use the unique key style field:

```graphql
query test {
  user_by_databaseId(databaseId: 1) {
    fullName
    email
    status
  }
}
```

## 7) Use unique key lookups

If a table has a unique index, you get a direct lookup field. For example:

```graphql
{
  user_by_email(email: "ben.smith@example.com") {
    id
    email
    status
  }
}
```

## 8) Composite primary key lookup (order items)

The tutorial dataset models `order_items` with a composite primary key: `(order_id, product_id)`.

Step A: fetch a few tuples and copy one `orderId` + `productId` pair:

```graphql
query {
  orderItems(first: 5, orderBy: { orderId: ASC }) {
    nodes {
      id
      orderId
      productId
      quantity
      unitPrice
    }
  }
}
```

Step B: use the composite raw lookup field with a tuple from Step A:

```graphql
query {
  orderItem_by_orderId_productId(orderId: <orderId>, productId: <productId>) {
    orderId
    productId
    quantity
    unitPrice
    order {
      status
      total
    }
    product {
      name
      sku
    }
  }
}
```

Step C: optionally resolve the same row by global Node ID:

```graphql
query {
  orderItem(id: "<id-from-step-a>") {
    orderId
    productId
    quantity
    unitPrice
  }
}
```

---
# Related Docs

## Next steps
- [Local OIDC](local-oidc.md)
- [Ops guardrails](ops-guardrails.md)

## Reference
- [Schema filters](../reference/schema-filters.md)
- [Endpoints](../reference/endpoints.md)

## Further reading
- [Performance constraints](../explanation/performance-constraints.md)
- [Query planning](../explanation/query-planning.md)

## Back
- [Tutorials home](README.md)
- [Docs home](../README.md)
