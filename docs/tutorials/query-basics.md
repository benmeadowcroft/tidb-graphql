# Query with filters and unique keys

This tutorial shows examples using the data that was loaded in the [Your first schema in five minutes](./first-schema.md) tutorial. You can follow along with your own data, but the names of objects generated by the schema introspection will be different so please adjust queries accordingly.

Goal: make a couple of real queries and see how the schema is shaped.

## 1) Find the types

GraphQL uses well know objects to make know the GraphQL schema, we will query those so we can see what types have been discovered:

```graphql
{
  __schema {
    types {
      name
      kind
    }
  }
}
```

Pick the object type that matches the table you are interested in querying.

## 2) Query rows

Using the schema created from the [sample-data.sql](./sample-data.sql) we will query the users table:

```graphql
query BasicUserQuery {
  users {
  	fullName
    email
    status
  }
}
```

Note: You can give a query an optional name, in this case we called our query `BasicUserQuery`.

## 3) Use filters

TiDB GraphQL enables you to create filters on certain columns. Filters mirror SQL WHERE semantics.

For example, we can filter the users to those who do not have certain statuses:

```graphql
query {
  users(where: { status: { notIn: ["pending" "inactive"] } }) {
    fullName
    email
    status
  }
}
```

You can combine filters with `and` / `or`, and compare with `lt`, `lte`, `gt`, `gte`, `ne`, etc.

## 4) Sort results with orderBy

Sorting uses `orderBy` with a list of fields and directions:

```graphql
query {
  users(orderBy:{createdAt:DESC}) {
    fullName
    email
    status
  }
}
```

## 5) Limit and pagination of results

TiDB GraphQL includes support for limiting results sets, along with offsets to support pagination of result sets.

For example, returning the first 2 results (using limit):

```graphql
query {
  users(orderBy:{createdAt:DESC}, limit:2) {
    fullName
    email
    status
  }
}
```

Next, returning the next 2 results (using limit + offset)

```graphql
query {
  users(orderBy:{createdAt:DESC}, limit:2, offset:2) {
    fullName
    email
    status
  }
}
```

## 6) Fetch by primary key

Every table with a primary key gets a `_by_pk` lookup field:

```graphql
query test {
  user_by_pk(id:1){
    fullName
    email
    status
  }
}
```

This compiles to a direct indexed lookup and returns a single object (or null if not found).

For tables with composite primary keys, pass all key columns.

## 7) Use unique key lookups

If a table has a unique index, you get a direct lookup field. For example:

```graphql
{
  user_by_email(email: "ben.turner@example.com") {
    id
    email
    status
  }
}
```

---
# Related Docs

## Next steps
- [Local OIDC](local-oidc.md)
- [Ops guardrails](ops-guardrails.md)

## Reference
- [Schema filters](../reference/schema-filters.md)
- [Endpoints](../reference/endpoints.md)

## Further reading
- [Performance constraints](../explanation/performance-constraints.md)
- [Query planning](../explanation/query-planning.md)

## Back
- [Tutorials home](README.md)
- [Docs home](../README.md)
